'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bsv = require('bsv');
var buffer = require('buffer');

/**
 * This module performs a simple check on the bsv.js version to ensure
 * compatiblity. If an incorrect version is detected, a helpful error is thrown
 * instead of waiting for other weird errors to surface later.
 */
if ( !(bsv.version && bsv.version.match(/^2\./)) ) {
  throw new Error(`BSV version error. TxForge requires bsv@^2. Version ${ bsv.version } detected.`)
}

/**
 * OP_RETURN cast
 * 
 * OP_RETURNS are frequently used to create transaction outputs containing
 * arbitrary data.
 * 
 * The cast automatically handles your given data array containing strings,
 * hex-strings, buffers and OpCodes, and processes it into a Script.
 */
const OP_RETURN = {
  /**
   * OP_RETURN lockingScript
   * 
   * The expected parameters are:
   * 
   * * `data` - an array of data chunks (see below)
   * * `safe` - set to false for spendable OP_RETURNS (defaults true)
   * 
   * The data array can contain any of the following types of element:
   * 
   * * Strings
   * * Hex-encoded strings, eg: `0xfafbfcfd`
   * * Raw buffers or typed arrays
   * * OpCode numbers
   * 
   * Example:
   * 
   * ```
   * Cast.lockingScript(OP_RETURN, {
   *   satoshis: 0,
   *   data: [
   *     '0x48656c6c6f20776f726c64',
   *     'Hello world',
   *     Buffer.from('Hello world'),
   *     new Uint8Array([72, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]),
   *     OpCode.OP_FALSE
   *   ]
   * })
   * ```
   */
  lockingScript: {
    script: [
      // 1. OP_FALSE (if safe)
      ({ safe = true }) => safe ? bsv.OpCode.OP_FALSE : undefined,

      // 2. OP_RETURN
      bsv.OpCode.OP_RETURN,

      // 3. Arbitrary data
      function({ data }) {
        // Iterates over data params and returns a Script instance
        return data.reduce((script, item) => {
          // Hex string
          if (typeof item === 'string' && /^0x/i.test(item)) {
            script.writeBuffer(buffer.Buffer.from(item.slice(2), 'hex'));
          }
          // Opcode number
          else if (typeof item === 'number' || item === null) {
            script.writeOpCode(Number.isInteger(item) ? item : 0);
          }
          // Opcode
          else if (typeof item === 'object' && item.hasOwnProperty('op')) {
            script.writeOpCode(item.op);
          }
          // All else
          else {
            script.writeBuffer(buffer.Buffer.from(item));
          }
          
          return script
        }, new bsv.Script())
      }
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size(params) {
      const scriptLen = this.getScript(params).toBuffer().length;
      return (params.safe ? 1 : 0) + 1 + bsv.VarInt.fromNumber(scriptLen).buf.length + scriptLen
    },

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(Array.isArray(params.data) && params.data.length)) {
        throw new Error('OP_RETURN script requires data array')
      }
    }
  }
};

/**
 * P2MS (multisig) cast
 * 
 * Build and spend multisig transactions, using the locking and unlocking
 * scripts available in this cast.
 */
const P2MS = {
  /**
   * P2MS lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `threshold` - the number of signatures required to unlock the UTXO
   * * `pubKeys` - array of bsv PubKey objects 
   * 
   * Example:
   * 
   * ```
   * // Creates 2 of 3 multisig lockingScript
   * Cast.lockingScript(P2MS, { satoshis: 1000, threshold: 2, pubKeys: [pk1, pk2, pk3] })
   * ```
   */
  lockingScript: {
    script: [
      // 1. Threshold Op
      ({ threshold }) => threshold + bsv.OpCode.OP_1 - 1,

      // 2. PubKeys
      function({ pubKeys }) {
        return pubKeys.reduce((script, pubKey) => {
          script.writeBuffer(pubKey.toBuffer());
          return script
        }, new bsv.Script())
      },

      // 3. PubKeys Op
      ({ pubKeys }) => pubKeys.length + bsv.OpCode.OP_1 - 1,

      // 4. OP_CHECKMULTISIG
      bsv.OpCode.OP_CHECKMULTISIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size: ({ pubKeys }) => 2 + (pubKeys.length * 34),

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (typeof params.threshold !== 'number') {
        throw new Error('P2MS lockingScript requires threshold (M-of-N)')
      }
      if (!(Array.isArray(params.pubKeys) && params.pubKeys.every(k => !!k.point))) {
        throw new Error('P2MS lockingScript requires pubKeys')
      }
    }
  },

  /**
   * P2MS unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `keyPairs` - array of bsv KeyPair objects
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2MS, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript with 2 keyPairs (assuming vin 0)
   * forge.signTxIn(0, { keyPairs: [k1, k2] })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. OP_0 required
      bsv.OpCode.OP_0,

      // 2. Sigs
      function(ctx, {
        keyPairs,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Tx.SCRIPT_ENABLE_SIGHASH_FORKID
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const script = new bsv.Script();
        // Iterrate over each of the locking script pubKeys
        for (let i = 1; i < txOut.script.chunks.length-2; i++) {
          let keyPair = keyPairs.find(k => {
            return buffer.Buffer.compare(txOut.script.chunks[i].buf, k.pubKey.toBuffer()) === 0
          });
          const sig = tx.sign(keyPair, sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
          script.writeBuffer(sig.toTxFormat());
        }
        return script
      }
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size: (params) => 1 + ((params.keyPairs ? params.keyPairs.length : 2) * 73),
    

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!params.keyPairs) throw new Error('P2MS unlockingScript requires valid keyPairs')
      if (!verifyKeyPairs(params.keyPairs, ctx.txOut)) {
        throw new Error('P2MS unlockingScript keyPairs must match lockingScript pubKeys')
      }
    }
  }
};

// Helper function verifies all given keyPairs match pubKeys in txOut
function verifyKeyPairs(keyPairs, { script }) {
  return Array.isArray(keyPairs) && keyPairs.every(keyPair => {
    return !!(
      keyPair.pubKey &&
      script.chunks.some(c => {
        return c.buf && buffer.Buffer.compare(c.buf, keyPair.pubKey.toBuffer()) === 0
      })
    )
  })
}

/**
 * P2PK (pay-to-pubKey) cast
 * 
 * Build and spend pay-to-pubKey transactions, using the locking and unlocking
 * scripts available in this cast.
 */
const P2PK = {
  /**
   * P2PK lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `pubKey` - the bsv PubKey object to pay to
   * 
   * Example:
   * 
   * ```
   * // Creates P2PK lockingScript
   * Cast.lockingScript(P2PK, { satoshis: 1000, pubKey })
   * ```
   */
  lockingScript: {
    script: [
      // 1. PubKey
      ({ pubKey }) => pubKey.toBuffer(),

      // 2. OP_CHECKSIG
      bsv.OpCode.OP_CHECKSIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 35,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(params.pubKey && params.pubKey.point)) {
        throw new Error('P2PK lockingScript requires pubKey')
      }
    }
  },

  /**
   * P2PK unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `keyPair` - bsv KeyPair object
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2PK, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript a keyPair (assuming vin 0)
   * forge.signTxIn(0, { keyPair })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. Sig
      function(ctx, {
        keyPair,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Tx.SCRIPT_ENABLE_SIGHASH_FORKID
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const sig = tx.sign(keyPair, sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
        return sig.toTxFormat()
      }
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 73,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!params.keyPair || !verifyKeyPair(params.keyPair, ctx.txOut)) {
        throw new Error('P2PK unlockingScript requires valid keyPair')
      }
    }
  }
};

// Helper function verifies the given keyPair matches the pubKey in txOut
function verifyKeyPair(keyPair, { script }) {
  return !!(
    script.chunks.length === 2 &&
    script.chunks[0].buf &&
    buffer.Buffer.compare(script.chunks[0].buf, keyPair.pubKey.toBuffer()) === 0
  )
}

/**
 * P2PKH (pay-to-pubKeyHash) cast
 * 
 * Build and spend pay-to-pubKeyHash transactions, using the locking and
 * unlocking scripts available in this cast.
 */
const P2PKH = {
  /**
   * P2PKH lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `address` - the bsv Address object to pay to
   * 
   * Example:
   * 
   * ```
   * // Creates P2PK lockingScript
   * Cast.lockingScript(P2PKH, { satoshis: 1000, address })
   * ```
   */
  lockingScript: {
    script: [
      // 1. OpCodes
      bsv.OpCode.OP_DUP,
      bsv.OpCode.OP_HASH160,

      // 2. PubKeyHash
      ({ address }) => address.hashBuf,

      // 3. OpCodes
      bsv.OpCode.OP_EQUALVERIFY,
      bsv.OpCode.OP_CHECKSIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 25,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(params.address && params.address.hashBuf)) {
        throw new Error('P2PKH lockingScript requires address')
      }
    }
  },

  /**
   * P2PKH unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `keyPair` - bsv KeyPair object
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2PKH, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript a keyPair (assuming vin 0)
   * forge.signTxIn(0, { keyPair })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. Sig
      function(ctx, {
        keyPair,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Tx.SCRIPT_ENABLE_SIGHASH_FORKID
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const sig = tx.sign(keyPair, sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
        return sig.toTxFormat()
      },

      // 2. PubKey
      (_ctx, { keyPair }) => keyPair.pubKey.toBuffer()
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 107,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!(params.keyPair && verifyKeyPair$1(params.keyPair, ctx.txOut))) {
        throw new Error('P2PKH unlockingScript requires valid keyPair')
      }
    }
  }
};

// Helper function verifies the given keyPair matches the pubKey in txOut
function verifyKeyPair$1(keyPair, { script }) {
  const hashBuf = bsv.Address.fromPubKey(keyPair.pubKey).hashBuf;
  return !!(
    script.chunks.length === 5 &&
    script.chunks[2].buf &&
    buffer.Buffer.compare(script.chunks[2].buf, hashBuf) === 0
  )
}

// Patch OpCodes until added to bsv2
// https://github.com/moneybutton/bsv/issues/161
bsv.OpCode.OP_SPLIT = 0x7f;

const defaultRHash = 'PayToRHASH160';

/**
 * P2RPH (R-Puzzle) cast
 * 
 * Build and spend R-Puzzles, using the locking and unlocking scripts available
 * in this cast.
 * 
 * This cast wouldn't be possible without Dean Little revealing how R-Puzzles
 * actually work in his library, [rpuzzle](https://github.com/deanmlittle/rpuzzle).
 * Much of the code in this module is adapted from Dean's work.
 */
const P2RPH = {
  /**
   * P2RPH lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `type` - the hash algorithm to use (defaults to 'PayToRHASH160')
   * * `rBuf` - the R value in a Buffer or typed array
   * 
   * Example:
   * 
   * ```
   * // Creates R-Puzzle lockingScript
   * Cast.lockingScript(P2RPH, { satoshis: 0, rBuf })
   * ```
   */
  lockingScript: {
    script: [
      // 1. OpCodes
      bsv.OpCode.OP_OVER,
      bsv.OpCode.OP_3,
      bsv.OpCode.OP_SPLIT,
      bsv.OpCode.OP_NIP,
      bsv.OpCode.OP_1,
      bsv.OpCode.OP_SPLIT,
      bsv.OpCode.OP_SWAP,
      bsv.OpCode.OP_SPLIT,
      bsv.OpCode.OP_DROP,

      // 2. Hash type OpCode
      ({type = defaultRHash}) => RPuzzleTypes[type].op,

      // 3. rBufHash
      ({ type = defaultRHash, rBuf }) => RPuzzleTypes[type].hash(rBuf),

      // 4. OpCodes
      bsv.OpCode.OP_EQUALVERIFY,
      bsv.OpCode.OP_CHECKSIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size({ type = defaultRHash }) {
      return 12 + (RPuzzleTypes[type].op ? 1 : 0) + RPuzzleTypes[type].size
    },

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(params.rBuf && buffer.Buffer.isBuffer(params.rBuf))) {
        throw new Error('P2RPH lockingScript requires rBuf')
      }
    }
  },

  /**
   * P2RPH unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `kBuf` - the K value in a Buffer or typed array
   * * `keyPair` - the bsv KeyPair to sign with (will generate ephemeral key if blank)
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2RPH, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript with kBuf and keyPair (assuming vin 0)
   * forge.signTxIn(0, { kBuf, keyPair })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. Sig
      function(ctx, {
        kBuf,
        keyPair,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Interp.SCRIPT_VERIFY_MINIMALDATA | bsv.Interp.SCRIPT_ENABLE_SIGHASH_FORKID | bsv.Interp.SCRIPT_ENABLE_MAGNETIC_OPCODES | bsv.Interp.SCRIPT_ENABLE_MONOLITH_OPCODES
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const hashBuf = tx.sighash(sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
        const sig = new bsv.Ecdsa()
          .fromObject({
            hashBuf,
            keyPair,
            endian: 'little',
            k: bsv.Bn.fromBuffer(kBuf)
          })
          .sign().sig;

        sig.fromObject({ nHashType: sighashType });
        return sig.toTxFormat()
      },

      // 2. PubKey
      (_ctx, { keyPair }) => keyPair.pubKey.toBuffer()
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 107,

    /**
     * Generats a random bsv KeyPair if not already defined
     * 
     * @param {Object} params Cast params
     * @returns {Object}
     */
    setup({ keyPair }) {
      if (!keyPair) keyPair = bsv.KeyPair.fromRandom();
      return { keyPair }
    },

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!(params.kBuf && verifyKBuf(params.kBuf, ctx.txOut))) {
        throw new Error('P2RPH unlockingScript requires valid kBuf')
      }
    }
  }
};


// The available hashing algos
// Use PayToR to pay to the bare R value
const RPuzzleTypes = {
  PayToRHASH160: {
    op: bsv.OpCode.OP_HASH160,
    hash: bsv.Hash.sha256Ripemd160,
    size: 20
  },
  PayToRRIPEMD160: {
    op: bsv.OpCode.OP_RIPEMD160,
    hash: bsv.Hash.ripemd160,
    size: 20
  },
  PayToRSHA256: {
    op: bsv.OpCode.OP_SHA256,
    hash: bsv.Hash.sha256,
    size: 32
  },
  PayToRHASH256: {
    op: bsv.OpCode.OP_HASH256,
    hash: bsv.Hash.sha256Sha256,
    size: 32
  },
  PayToRSHA1: {
    op: bsv.OpCode.OP_SHA1,
    hash: bsv.Hash.sha1,
    size: 20
  },
  PayToR: {
    hash: (r) => { return r },
    size: 32
  }
};

// Helper function verifies the kBuf matches the R Hash in txOut
function verifyKBuf(kBuf, { script }) {
  const rBuf = getRBuf(kBuf);

  // Pay to Rpuzzle Hash
  if (script.chunks.length === 13) {
    let type = Object.keys(RPuzzleTypes)
      .filter(key => RPuzzleTypes[key].op === script.chunks[9].opCodeNum)
      .map(key => RPuzzleTypes[key])[0];

    return !!(
      script.chunks[9].opCodeNum &&
      script.chunks[10].buf &&
      buffer.Buffer.compare(script.chunks[10].buf, type.hash(rBuf)) === 0
    )
    
  // Pay to Rpuzzle R value
  } else if (script.chunks.length === 12) {
    return !!(
      script.chunks[9].buf &&
      buffer.Buffer.compare(script.chunks[9].buf, rBuf) === 0
    )
  
  // Just false
  } else {
    return false
  }
}

// Helper function converts kBuf to rBuf
function getRBuf(kBuf) {
  const k = bsv.Bn.fromBuffer(kBuf),
        G = bsv.Point.getG(),
        N = bsv.Point.getN(),
        Q = G.mul(k),
        r = buffer.Buffer.from( Q.x.umod(N).toArray() );

  return r[0]>127 ? buffer.Buffer.concat([buffer.Buffer.alloc(1), r]) : r;
}

exports.OP_RETURN = OP_RETURN;
exports.P2MS = P2MS;
exports.P2PK = P2PK;
exports.P2PKH = P2PKH;
exports.P2RPH = P2RPH;
